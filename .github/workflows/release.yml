name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  release:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'aarch64'
            friendly_name: 'MacBook-AppleSilicon'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'x86_64'
            friendly_name: 'MacBook-Intel'
          - platform: 'ubuntu-22.04'
            args: ''
            arch: 'amd64'
            friendly_name: 'Linux'
          - platform: 'windows-latest'
            args: ''
            arch: 'x64'
            friendly_name: 'Windows'

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
          cache-dependency-path: zapcut/package-lock.json

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Download FFmpeg binaries (macOS Apple Silicon)
        if: matrix.platform == 'macos-latest' && matrix.arch == 'aarch64'
        run: |
          cd zapcut/src-tauri/binaries/macos-aarch64
          echo "Downloading FFmpeg for macOS Apple Silicon..."
          curl -L https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip -o ffmpeg.zip
          curl -L https://evermeet.cx/ffmpeg/getrelease/ffprobe/zip -o ffprobe.zip
          unzip -o ffmpeg.zip
          unzip -o ffprobe.zip
          rm ffmpeg.zip ffprobe.zip
          chmod +x ffmpeg ffprobe
          ls -lah ffmpeg ffprobe
          ./ffmpeg -version | head -1

      - name: Download FFmpeg binaries (macOS Intel)
        if: matrix.platform == 'macos-latest' && matrix.arch == 'x86_64'
        run: |
          cd zapcut/src-tauri/binaries/macos-x86_64
          echo "Downloading FFmpeg for macOS Intel..."
          curl -L https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip -o ffmpeg.zip
          curl -L https://evermeet.cx/ffmpeg/getrelease/ffprobe/zip -o ffprobe.zip
          unzip -o ffmpeg.zip
          unzip -o ffprobe.zip
          rm ffmpeg.zip ffprobe.zip
          chmod +x ffmpeg ffprobe
          ls -lah ffmpeg ffprobe
          ./ffmpeg -version | head -1

      - name: Download FFmpeg binaries (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          cd zapcut/src-tauri/binaries/linux-x86_64
          echo "Downloading FFmpeg for Linux..."
          wget -q https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz
          tar -xf ffmpeg-release-amd64-static.tar.xz
          mv ffmpeg-*-amd64-static/ffmpeg .
          mv ffmpeg-*-amd64-static/ffprobe .
          rm -rf ffmpeg-*-amd64-static*
          chmod +x ffmpeg ffprobe
          ls -lah ffmpeg ffprobe
          ./ffmpeg -version | head -1

      - name: Download FFmpeg binaries (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          cd zapcut/src-tauri/binaries/windows-x86_64
          Write-Host "Downloading FFmpeg for Windows..."
          Invoke-WebRequest -Uri "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip" -OutFile "ffmpeg.zip"
          Expand-Archive -Path "ffmpeg.zip" -DestinationPath "."
          $ffmpegDir = Get-ChildItem -Directory -Filter "ffmpeg-*" | Select-Object -First 1
          Move-Item -Path "$($ffmpegDir.FullName)\bin\ffmpeg.exe" -Destination "." -Force
          Move-Item -Path "$($ffmpegDir.FullName)\bin\ffprobe.exe" -Destination "." -Force
          Remove-Item -Recurse -Force $ffmpegDir, "ffmpeg.zip"
          Get-Item ffmpeg.exe, ffprobe.exe | Format-Table
          .\ffmpeg.exe -version | Select-Object -First 1

      - name: Install frontend dependencies
        run: |
          cd zapcut
          npm ci

      - name: Update tauri.conf.json with platform-specific FFmpeg binaries
        shell: bash
        run: |
          cd zapcut/src-tauri
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"
          
          # Determine which FFmpeg binaries to include for this platform
          if [[ "$PLATFORM" == "macos-latest" ]]; then
            if [[ "$ARCH" == "aarch64" ]]; then
              RESOURCES='["binaries/macos-aarch64/ffmpeg", "binaries/macos-aarch64/ffprobe"]'
            else
              RESOURCES='["binaries/macos-x86_64/ffmpeg", "binaries/macos-x86_64/ffprobe"]'
            fi
          elif [[ "$PLATFORM" == "ubuntu-22.04" ]]; then
            RESOURCES='["binaries/linux-x86_64/ffmpeg", "binaries/linux-x86_64/ffprobe"]'
          elif [[ "$PLATFORM" == "windows-latest" ]]; then
            RESOURCES='["binaries/windows-x86_64/ffmpeg.exe", "binaries/windows-x86_64/ffprobe.exe"]'
          fi
          
          echo "Platform: $PLATFORM, Arch: $ARCH"
          echo "Setting resources to: $RESOURCES"
          
          # Update tauri.conf.json - use Python for reliable JSON manipulation
          python3 << 'EOF'
          import json
          
          with open('tauri.conf.json', 'r') as f:
              config = json.load(f)
          
          resources = $RESOURCES
          config['bundle']['resources'] = resources
          
          with open('tauri.conf.json', 'w') as f:
              json.dump(config, f, indent=2)
          
          print(f"Updated resources to: {resources}")
          EOF
          
          echo "Updated tauri.conf.json:"
          cat tauri.conf.json | grep -A 10 '"resources"'

      - name: Verify FFmpeg binaries exist
        shell: bash
        run: |
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"
          
          if [[ "$PLATFORM" == "macos-latest" ]]; then
            if [[ "$ARCH" == "aarch64" ]]; then
              BIN_DIR="zapcut/src-tauri/binaries/macos-aarch64"
            else
              BIN_DIR="zapcut/src-tauri/binaries/macos-x86_64"
            fi
          elif [[ "$PLATFORM" == "ubuntu-22.04" ]]; then
            BIN_DIR="zapcut/src-tauri/binaries/linux-x86_64"
          elif [[ "$PLATFORM" == "windows-latest" ]]; then
            BIN_DIR="zapcut/src-tauri/binaries/windows-x86_64"
          fi
          
          echo "Verifying FFmpeg binaries in: $BIN_DIR"
          ls -lah "$BIN_DIR/" || (echo "Directory not found!" && exit 1)
          
          # Verify binaries exist
          if [[ ! -f "$BIN_DIR/ffmpeg"* ]] && [[ ! -f "$BIN_DIR/ffmpeg.exe" ]]; then
            echo "❌ ERROR: No FFmpeg binary found in $BIN_DIR"
            exit 1
          fi
          echo "✅ FFmpeg binaries verified"
  
      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS code signing (optional - comment out if not using)
          # APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          # APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          # APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # APPLE_ID: ${{ secrets.APPLE_ID }}
          # APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          # APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          projectPath: zapcut
          tagName: ${{ github.ref_name }}
          releaseName: 'ZapCut ${{ github.ref_name }}'
          releaseBody: 'See the assets below to download this version and install.'
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.args }}

      - name: Rename release assets to user-friendly names
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          PLATFORM="${{ matrix.platform }}"
          FRIENDLY_NAME="${{ matrix.friendly_name }}"
          TAG="${{ github.ref_name }}"
          
          # Determine patterns for sed based on platform
          if [[ "$PLATFORM" == "macos-latest" ]]; then
            # macOS renaming
            PATTERN1="s/_aarch64/_${FRIENDLY_NAME}/g"
            PATTERN2="s/_x64/_${FRIENDLY_NAME}/g"
          elif [[ "$PLATFORM" == "ubuntu-22.04" ]]; then
            # Linux renaming
            PATTERN1="s/_amd64/_${FRIENDLY_NAME}/g"
          elif [[ "$PLATFORM" == "windows-latest" ]]; then
            # Windows renaming
            PATTERN1="s/_x64-setup/_${FRIENDLY_NAME}-setup/g"
            PATTERN2="s/_x64_/_${FRIENDLY_NAME}_/g"
          fi
          
          # Get assets and rename them
          gh release view "$TAG" --json assets -q '.assets[].name' | while read ASSET_NAME; do
            NEW_NAME="$ASSET_NAME"
            
            # Apply patterns
            if [[ ! -z "$PATTERN1" ]]; then
              NEW_NAME=$(echo "$NEW_NAME" | sed "$PATTERN1")
            fi
            if [[ ! -z "$PATTERN2" ]]; then
              NEW_NAME=$(echo "$NEW_NAME" | sed "$PATTERN2")
            fi
            
            # Update the asset name if it changed
            if [[ "$NEW_NAME" != "$ASSET_NAME" ]]; then
              echo "Renaming: $ASSET_NAME -> $NEW_NAME"
              # Use GitHub API to update asset name
              ASSET_ID=$(gh release view "$TAG" --json assets -q ".assets[] | select(.name==\"$ASSET_NAME\") | .id")
              curl -X PATCH \
                -H "Authorization: token $GH_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/releases/assets/$ASSET_ID" \
                -d "{\"name\":\"$NEW_NAME\"}"
              echo "✓ Renamed to: $NEW_NAME"
            fi
          done

